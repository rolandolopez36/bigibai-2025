import { test, expect } from "@playwright/test";

/**
 * ðŸ”´ TEST DE SEGURIDAD: Rate Limit Vulnerability
 *
 * Este test demuestra la vulnerabilidad identificada en el sistema de rate limiting
 * del formulario de newsletter.
 *
 * VULNERABILIDAD:
 * - El rate limit usa SOLO el email como identificador
 * - LÃ­mite: 5 intentos por hora POR EMAIL
 * - Un atacante puede evadir el lÃ­mite rotando emails
 *
 * IMPACTO:
 * - Spam masivo en la base de datos
 * - Consumo excesivo de cuota Redis/Supabase
 * - Aumento de costos operativos
 *
 * SEVERIDAD: ALTA
 * PROBABILIDAD: >90% en producciÃ³n
 */

test.describe("ðŸ”´ Vulnerabilidad: Rate Limit evadible por rotaciÃ³n de emails", () => {
  // Allow enough time for multiple attempts
  test.describe.configure({ timeout: 120_000 });

  test("debe permitir mÃºltiples suscripciones rotando emails (VULNERABILIDAD)", async ({
    page,
  }) => {
    await page.goto("/");

    const emailInput = page.locator('input[name="email"]');
    const submitButton = page.locator('button[type="submit"]');

    const isNewsletterPost = (res: any) =>
      res.url().includes("/_actions/newsletter") &&
      res.request().method() === "POST";

    let successfulSubmissions = 0;
    const totalAttempts = 10;

    for (let i = 1; i <= totalAttempts; i++) {
      const uniqueEmail = `attacker${i}@tempmail.com`;

      await emailInput.fill(uniqueEmail);

      const [resp] = await Promise.all([
        page.waitForResponse(isNewsletterPost, { timeout: 15_000 }),
        submitButton.click(),
      ]);

      if (resp.ok()) {
        successfulSubmissions++;
        console.log(`âœ… Email ${i} registrado: ${uniqueEmail}`);
      } else {
        console.log(
          `ðŸ”’/âŒ Email ${i} status=${resp.status()} url=${resp.url()}`
        );
      }

      await page.waitForTimeout(100);
    }

    console.log(
      `\nðŸ“Š Resultado del ataque: intentos=${totalAttempts} Ã©xitos=${successfulSubmissions}`
    );

    // OpciÃ³n A: el test PASA cuando la vulnerabilidad existe
    if (successfulSubmissions > 5) {
      console.log(
        `\nðŸ”´ VULNERABILIDAD CONFIRMADA: ${successfulSubmissions} registros (>5/hr) con emails Ãºnicos.`
      );
      expect(successfulSubmissions).toBeGreaterThan(5);
    } else {
      console.log(
        `\nâœ… Rate limit efectivo: ${successfulSubmissions}/${totalAttempts} Ã©xitos.`
      );
      expect(successfulSubmissions).toBeLessThanOrEqual(5);
    }

    // At least one should succeed to ensure the endpoint works
    expect(successfulSubmissions).toBeGreaterThan(0);
  });

  test("debe bloquear el mismo email despuÃ©s de 5 intentos (FUNCIONA)", async ({
    page,
  }) => {
    await page.goto("/");

    const emailInput = page.locator('input[name="email"]');
    const submitButton = page.locator('button[type="submit"]');
    const messageDiv = page.locator("#newsletter-message");

    const isNewsletterPost = (res: any) =>
      res.url().includes("/_actions/newsletter") &&
      res.request().method() === "POST";

    const fixedEmail = `test-rate-limit-${Date.now()}@example.com`;
    let blockedAttempt = false;

    for (let i = 1; i <= 7; i++) {
      await emailInput.fill(fixedEmail);

      const [resp] = await Promise.all([
        page.waitForResponse(isNewsletterPost, { timeout: 15_000 }),
        submitButton.click(),
      ]);

      const messageText = await messageDiv.textContent();
      console.log(
        `Intento ${i}: status=${resp.status()} msg="${messageText ?? ""}"`
      );

      // Assume app returns non-2xx or shows "intento" when rate limited
      if (!resp.ok() || (messageText ?? "").toLowerCase().includes("intento")) {
        blockedAttempt = true;
        console.log(`âœ… Rate limit activado en el intento ${i}`);
        break;
      }

      await page.waitForTimeout(200);
    }

    expect(blockedAttempt).toBe(true);
    console.log(
      `\nâœ… El rate limit POR EMAIL funciona correctamente para repetidos.`
    );
  });

  test.skip("DEMO: Simular ataque con 20 emails diferentes", async ({
    page,
  }) => {
    await page.goto("/");

    const results = { success: 0, rateLimit: 0, error: 0, duplicate: 0 };

    for (let i = 1; i <= 20; i++) {
      const email = `attack-demo-${Date.now()}-${i}@evil.com`;
      await page.fill('input[name="email"]', email);
      await page.click('button[type="submit"]');
      await page.waitForTimeout(1000);

      const message = await page.locator("#newsletter-message").textContent();

      if (message?.includes("suscrito")) results.success++;
      else if (message?.includes("intento")) results.rateLimit++;
      else if (message?.includes("ya estaba")) results.duplicate++;
      else results.error++;

      await page.waitForTimeout(200);
    }

    console.log("\nðŸ“Š Resultados del ataque simulado:", results);

    if (results.success > 5) {
      console.log(
        `\nðŸ”´ VULNERABILIDAD: ${results.success} emails registrados con rotaciÃ³n.`
      );
    }
  });
});

test.describe("ðŸ›¡ï¸ SoluciÃ³n propuesta (pendiente de implementar)", () => {
  test.skip("debe limitar por IP ademÃ¡s de email", async ({ page }) => {
    await page.goto("/");

    let blockedByIp = false;

    for (let i = 1; i <= 15; i++) {
      const email = `user${i}@different-emails.com`;
      await page.fill('input[name="email"]', email);
      await page.click('button[type="submit"]');
      await page.waitForTimeout(800);

      const message = await page.locator("#newsletter-message").textContent();
      if (i > 10 && (message ?? "").includes("intento")) {
        blockedByIp = true;
        break;
      }
    }

    expect(blockedByIp).toBe(true);
  });
});
